import os
from yacs.config import CfgNode as CN

_C = CN()

_C.model = CN()
_C.model.device = "cuda"
_C.dbg = False
_C.deterministic = False
_C.model.meta_architecture = "PokingRecon"
_C.model.pokingrecon = CN()
_C.model.pokingrecon.nobjs = 1
_C.model.pokingrecon.vi_shift = 0
_C.model.pokingrecon.frame_ids = []
_C.model.pokingrecon.optim_pose = True
_C.model.pokingrecon.fix_bg = False
_C.model.pokingrecon.pose_init = [0, 0, 0, 0, 0, 0]
_C.model.pokingrecon.rand_method = 'random'  # or mask_random
_C.model.pokingrecon.rand_mask_ratio = 0.5
_C.model.pokingrecon.recon = False
_C.model.pokingrecon.recon_N = 512
_C.model.pokingrecon.recon_volume_size = 2.0
_C.model.pokingrecon.netdepth = 8
_C.model.pokingrecon.netwidth = 256
_C.model.pokingrecon.netdepth_fine = 8
_C.model.pokingrecon.netwidth_fine = 256
_C.model.pokingrecon.N_rand = 1024
_C.model.pokingrecon.chunk = 1024 * 32
_C.model.pokingrecon.val_chunk = 4096
_C.model.pokingrecon.netchunk = 1024 * 64
_C.model.pokingrecon.N_samples = 64
_C.model.pokingrecon.rgb_loss = 'l1'
_C.model.pokingrecon.flow_loss_weight = 0.02
_C.model.pokingrecon.perturb = 1
_C.model.pokingrecon.use_viewdirs = True
_C.model.pokingrecon.i_embed = 0
_C.model.pokingrecon.multires = 10
_C.model.pokingrecon.multires_views = 4
_C.model.pokingrecon.raw_noise_std = 0
_C.model.pokingrecon.white_bkgd = False
_C.model.pokingrecon.white_bkgd_color_inf = 0
_C.model.pokingrecon.lindisp = False
_C.model.pokingrecon.retraw = True
_C.model.pokingrecon.num_frames = 1
_C.model.pokingrecon.init_pose_at_frame = [-1]
_C.model.pokingrecon.dynamic_on = False
_C.model.pokingrecon.static_on = True
_C.model.pokingrecon.mdepth_loss_on = False
_C.model.pokingrecon.mdepth_loss_weight = 0.1
_C.model.pokingrecon.mdepth_loss_bg_on = False
_C.model.pokingrecon.mdepth_loss_bg_weight = 0.1
_C.model.pokingrecon.mdepth_postprocess = False
_C.model.pokingrecon.mdepth_fill = False
_C.model.pokingrecon.mdepth_fill_use_pred = False
_C.model.pokingrecon.mdepth_fill_thresh = 0.0
_C.model.pokingrecon.mdepth_fill_thresh_eval = -1.0  # if negative, use mdepth_fill_thresh, else use mdepth_fill_thresh_eval
_C.model.pokingrecon.mdepth_fill_bg = False
_C.model.pokingrecon.mdepth_fill_thresh_bg = 0.0
_C.model.pokingrecon.mdepth_fill_thresh_bg_eval = -1.0
_C.model.pokingrecon.depth_loss_on = True
_C.model.pokingrecon.depth_loss_lambda = 0.1
_C.model.pokingrecon.depth_loss_all = False
_C.model.pokingrecon.depth_loss_outside_mask = False
_C.model.pokingrecon.depth_loss_miniter = 0
_C.model.pokingrecon.depth_loss_func = 'mse'
_C.model.pokingrecon.dont_render_bg = False
_C.model.pokingrecon.dont_render_fg = []
_C.model.pokingrecon.eval_mask_gt_id = 0
_C.model.pokingrecon.trim_start = 1
_C.model.pokingrecon.sparse_loss = False
_C.model.pokingrecon.sparse_loss_weight = 0.01
_C.model.pokingrecon.sparse_loss_exp = False
_C.model.pokingrecon.sparse_loss_weighted = False
_C.model.pokingrecon.sparse_loss_decay = -20
_C.model.pokingrecon.motion_mask_loss = False
_C.model.pokingrecon.motion_mask_loss_all_area = False
_C.model.pokingrecon.motion_mask_loss_weight = 0.01
_C.model.pokingrecon.motion_mask_loss_exp = False
_C.model.pokingrecon.motion_mask_loss_erode_radius = 0
_C.model.pokingrecon.motion_mask_loss_min_iter = 0
_C.model.pokingrecon.motion_mask_loss_func = 'mean'
_C.model.pokingrecon.fix_volsdf = False
_C.model.pokingrecon.fix_objpose_optim_frame_ids = []
_C.model.pokingrecon.fix_objpose_optim_frame_ids_all_objs = []
_C.model.pokingrecon.smooth_loss_on = False
_C.model.pokingrecon.smooth_loss1_on = True
_C.model.pokingrecon.smooth_loss2_on = False
_C.model.pokingrecon.smooth_loss_weight = 0.1
_C.model.pokingrecon.pred_mask_thresh = 0.5
_C.model.pokingrecon.pretrained_volsdf = []
_C.model.pokingrecon.override_poses = True
_C.model.pokingrecon.override_poses_all_objs = []
_C.model.pokingrecon.znegfill = False
_C.model.pokingrecon.znegfill_thresh = 0.0
_C.model.pokingrecon.align_pose_eval = False
_C.model.pokingrecon.ignore_gripper = False

_C.model.pokingrecon.volsdf = CN()
_C.model.pokingrecon.volsdf.use_nerfplusplus = False
_C.model.pokingrecon.volsdf.obj_bounding_radius = 3.0
_C.model.pokingrecon.volsdf.W_geo_feat = 256
_C.model.pokingrecon.volsdf.speed_factor = 10.0
_C.model.pokingrecon.volsdf.beta_init = 0.1
_C.model.pokingrecon.volsdf.nobjs = 1
_C.model.pokingrecon.volsdf.input_ch = 3
_C.model.pokingrecon.volsdf.epsilon = 0.1
_C.model.pokingrecon.volsdf.max_upsample_steps = 6
_C.model.pokingrecon.volsdf.max_bisection_steps = 10
_C.model.pokingrecon.volsdf.perturb = True
_C.model.pokingrecon.volsdf.w_eikonal = 0.1
_C.model.pokingrecon.volsdf.use_nerfplusplus = False
_C.model.pokingrecon.volsdf.surface_cfg = CN()
_C.model.pokingrecon.volsdf.surface_cfg.use_siren = False
_C.model.pokingrecon.volsdf.surface_cfg.embed_multires = 6
_C.model.pokingrecon.volsdf.surface_cfg.radius_init = 1.0
_C.model.pokingrecon.volsdf.surface_cfg.geometric_init = True
_C.model.pokingrecon.volsdf.surface_cfg.D = 8
_C.model.pokingrecon.volsdf.surface_cfg.W = 256
_C.model.pokingrecon.volsdf.surface_cfg.skips = [4]
_C.model.pokingrecon.volsdf.surface_cfg.latent_size = 0
_C.model.pokingrecon.volsdf.radiance_cfg = CN()
_C.model.pokingrecon.volsdf.radiance_cfg.use_siren = False
_C.model.pokingrecon.volsdf.radiance_cfg.embed_multires = -1
_C.model.pokingrecon.volsdf.radiance_cfg.embed_multires_view = -1
_C.model.pokingrecon.volsdf.radiance_cfg.use_view_dirs = True
_C.model.pokingrecon.volsdf.radiance_cfg.latent_size = 0
_C.model.pokingrecon.volsdf.radiance_cfg.D = 4
_C.model.pokingrecon.volsdf.radiance_cfg.W = 256
_C.model.pokingrecon.volsdf.radiance_cfg.skips = []


_C.model.maskfusion = CN()
_C.model.maskfusion.voxel_length = 0.005
_C.model.maskfusion.scene_flow_filter = CN()
_C.model.maskfusion.scene_flow_filter.max_value = 0.5
_C.model.maskfusion.scene_flow_filter.min_value = 0.0
_C.model.maskfusion.scene_flow_filter.world_z_min = 0.01
_C.model.maskfusion.scene_flow_filter.world_z_max = 0.2
_C.model.maskfusion.icp = True
_C.model.maskfusion.icp_thresh = 0.01
_C.model.maskfusion.remove_plane = True
_C.model.maskfusion.remove_plane_thresh = 0.01
_C.model.maskfusion.eval_select = []
_C.model.maskfusion.fusion_use_open3d = True

_C.dataset = CN()

_C.dataset.kinectrobot = CN()
_C.dataset.kinectrobot.keep_frames = []
_C.dataset.kinectrobot.skip = 10
_C.dataset.kinectrobot.keep_only = -1
_C.dataset.kinectrobot.keep_only_samask = -1
_C.dataset.kinectrobot.remove_bg = False
_C.dataset.kinectrobot.data_scale = 1.0
_C.dataset.kinectrobot.near = -1000.0
_C.dataset.kinectrobot.far = -1000.0
_C.dataset.kinectrobot.clip_far = 1000.0
_C.dataset.kinectrobot.load_mask = True
_C.dataset.kinectrobot.load_motion_mask = True
_C.dataset.kinectrobot.load_segany_min_divider = 3
_C.dataset.kinectrobot.gripper_mask_dilate = 0
_C.dataset.kinectrobot.name = "moved"
_C.dataset.kinectrobot.sa_init_pose = []
_C.dataset.kinectrobot.mask_rgb_by_0mdepth = True
_C.dataset.kinectrobot.load_raft_flow = False
_C.dataset.kinectrobot.load_raft_bflow = False
_C.dataset.kinectrobot.load_raft_flow_intervals = []

_C.input = CN()
_C.input.transforms = []
_C.input.shuffle = True

_C.datasets = CN()
_C.datasets.train = ()
_C.datasets.test = ""

_C.dataloader = CN()
_C.dataloader.num_workers = 0
_C.dataloader.collator = 'DefaultBatchCollator'
_C.dataloader.pin_memory = False

_C.solver = CN()
_C.solver.num_epochs = 1
_C.solver.max_lr = 0.001
_C.solver.end_lr = 0.0001
_C.solver.end_pose_lr = 0.00001
_C.solver.bias_lr_factor = 1
_C.solver.momentum = 0.9
_C.solver.weight_decay = 0.0005
_C.solver.weight_decay_bias = 0.0
_C.solver.gamma = 0.1
_C.solver.gamma_pose = 0.1
_C.solver.lrate_decay = 250
_C.solver.lrate_decay_pose = 250
_C.solver.steps = (30000,)
_C.solver.warmup_factor = 1.0 / 3
_C.solver.warmup_iters = 500
_C.solver.warmup_method = "linear"
_C.solver.num_iters = 10000  # volsdf
_C.solver.min_factor = 0.1  # volsdf
_C.solver.pose_lr = 0.00005  # volsdf

_C.solver.optimizer = 'Adam'
_C.solver.scheduler = 'ExponentialScheduler'
_C.solver.scheduler_decay_thresh = 0.00005
_C.solver.do_grad_clip = False
_C.solver.grad_clip_type = 'norm'  # norm or value
_C.solver.grad_clip = 1.0
_C.solver.ds_len = -1
_C.solver.batch_size = 1
_C.solver.loss_function = ''
####save ckpt configs#####
_C.solver.save_min_loss = 20.0
_C.solver.save_every = False
_C.solver.save_freq = 1
_C.solver.save_mode = 'epoch'  # epoch or iteration
_C.solver.val_freq = 1
_C.solver.save_last_only = False
_C.solver.empty_cache = True
# _C.solver.force_no_resume = False
# save model config:
#  --->save model when smaller val loss is detected.
# save_every: True, save_mode: epoch --->save model when epoch % save_freq==0
# save_every: True, save_mode: iteration --->save model when epoch % save_freq==0
_C.solver.metric_functions = ()
_C.solver.trainer = "pokingrecon"
_C.solver.load_model = ""
_C.solver.load_model_extras = []
_C.solver.load = ""
_C.solver.print_it = False
_C.solver.detect_anomaly = False
_C.solver.convert_sync_batchnorm = False
_C.solver.ddp_version = 'torch'  # or puop
_C.solver.broadcast_buffers = False
_C.solver.find_unused_parameters = False
_C.solver.resume = False
_C.solver.dist = CN()
_C.solver.dist.sampler = CN()
_C.solver.dist.sampler.shuffle = False

_C.test = CN()
_C.test.batch_size = 1
_C.test.evaluators = []
_C.test.visualizer = 'default'
_C.test.force_recompute = True
_C.test.do_evaluation = True
_C.test.do_visualization = False
_C.test.eval_all = False
_C.test.eval_all_min = 0
_C.test.save_predictions = False
_C.test.training_mode = False
_C.test.ckpt_dir = ''
_C.test.show_pose_optim = True

_C.output_dir = ''
_C.backup_src = True
_C.mode = 'train'

_C.paths_catalog = os.path.join(os.path.dirname(__file__), "paths_catalog.py")

_C.recon = False
_C.dont_render_bg = False
_C.dont_render_fg = []
_C.retraw = True
_C.tf = 4
_C.mdepth_fill_thresh = 0.0
_C.SE3_LOG_MAP_BACKEND = 'pytorch3d'
